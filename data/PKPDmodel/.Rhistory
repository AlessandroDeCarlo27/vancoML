0.94,NA,1,1,
0.94,NA,1,1)
varNames <- c("expCrCl","CGeq","MDRDeq","dummy")
c_start <- matrix(values_corr, ncol = 4, nrow = 4)
rownames(c_start) <- varNames
colnames(c_start)<- varNames
colori <- brewer.pal(7, "Set3")
pal <- colorRampPalette(colori)
#plot correlation graph
plot_graph_corr(c_start,"Graph of Initial Correlation Matrix")
#alternative correlation matrix plot
#COL1(sequential = c("Oranges", "Purples", "Reds", "Blues", "Greens",
#                  "Greys", "OrRd", "YlOrRd", "YlOrBr", "YlGn"), n = 200)
corrplot(c_start, method="color",number.digits = 2,
addCoef.col = "black", # Add coefficient of correlation
tl.col="black", tl.srt=45, #Text label color and rotation
# hide correlation coefficient on the principal diagonal
diag=T,col.lim = c(20, 30),
col = pal(7))#COL1('YlGn'))
#get bounds of correlations
estimate_corr_bounds(c_start)
#estimate indirect correlations
corr_est_results <- prova(c_start)
#show final correlation matrix with estimated values
prova <- corr_est_results$corrMatFinal
plot_graph_corr(c_final,"Graph of Final Correlation Matrix")
#plot correlations estimated
corrplot(c_final, method="color",number.digits = 2,
addCoef.col = "black", # Add coefficient of correlation
tl.col="black", tl.srt=45, #Text label color and rotation
# hide correlation coefficient on the principal diagonal
diag=T,col.lim = c(20, 30),
col = pal(7))#COL1('YlGn'))
values_corr <- c(1.00,0.86,0.94,0.86,
0.86,1,NA,NA,
0.94,NA,1,1,
0.94,NA,1,1)
varNames <- c("expCrCl","CGeq","MDRDeq","dummy")
c_start <- matrix(values_corr, ncol = 4, nrow = 4)
values_corr <- c(1.00,0.86,0.94,0.86,
0.86,1,NA,NA,
0.94,NA,1,1,
0.94,NA,1,1)
varNames <- c("expCrCl","CGeq","MDRDeq","dummy")
c_start <- matrix(values_corr, ncol = 4, nrow = 4)
rownames(c_start) <- varNames
colnames(c_start)<- varNames
c_start
values_corr <- c(1.00,0.86,0.94,0.86,
0.86,1,NA,NA,
0.94,NA,1,1,
0.94,NA,1,1)
varNames <- c("expCrCl","CGeq","MDRDeq","dummy")
c_start <- matrix(values_corr, ncol = 4, nrow = 4)
c_start
values_corr <- c(1.00,0.86,0.94,0.86,
0.86,1,NA,NA,
0.94,NA,1,1,
0.94,NA,1,1)
varNames <- c("expCrCl","CGeq","MDRDeq","dummy")
c_start <- matrix(values_corr, ncol = 4, nrow = 4)
c_start
library(mvLognCorrEst)
library(corrplot)#plot of matrices
library(RColorBrewer)
prova <- function(corrMatStart,force_estimate=FALSE){
#VALIDATE INPUT
#validate_corrMatrix(corrMatStart)
#indirect correlations to estimate must be declared with NA inside the input matrix
if(!any(is.na(corrMatStart))){
stop("No indirect correlations to estimate are declared")
}
#bounds of correlation matrix
bounds <- estimate_corr_bounds(corrMatStart)
#test if all bounds are NA: this implies that all indirect correlations estimates will be set to 0
if(all(is.na(bounds[,3]))&&all(is.na(bounds[,4]))){
list_variables <- paste(paste(bounds[,1],bounds[,2],sep="--"),collapse = " ")
warning(paste("Cannot estimate indirect correlations, paths between all indicated variables are missing:\n",list_variables,sep=""))
plot_graph_corr(corrMatStart,'Independet Variables')
matOpt <- get_corrMatrixOptim(NULL,corrMatStart,bounds)
output_optim <- list()
output_optim[["corrMatFinal"]]<-matOpt
return(output_optim)
}
#set to 0 correlations to be estimated
corrMatStart[is.na(corrMatStart)]<-0
# get indices of couples for which an indirect effect exists according to
#graph path analysis
notNa_idx <- !(is.na(bounds[,3])&is.na(bounds[,4]))
x0 <- bounds[notNa_idx,3]+(sign(bounds[notNa_idx,3])*
((abs(bounds[notNa_idx,4])-abs(bounds[notNa_idx,3]))/2))
#solve constrained optimization problem
r <- pracma::fmincon(x0,optim.fun,lb=bounds[notNa_idx,3],
ub=bounds[notNa_idx,4],cbase=corrMatStart,
var_optim=bounds)
#compute correlation matrix with estimated indirect correlations
corrMatfinal <- get_corrMatrixOptim(r$par,corrMatStart,bounds)
output_optim <- list()
output_optim[["optimizationBounds"]] <-bounds
if(r$val<0){
#optimization successfull
output_optim[["optim"]]<-r
output_optim[["corrMatFinal"]] <- corrMatfinal
return(output_optim)
}else{
if(force_estimate){
warning("Optimization step-1 failed. Matrix obtained is not positive-semidefinite.
Matrix of step-1 will be approximated to its nearest positive definite correlation matrix.
This may change fixed correlations.")
output_optim[["optim1"]] <-r
r2 <- Matrix::nearPD(corrMatfinal,corr = TRUE)
output_optim[["optim2"]] <-r2
output_optim[["corrMatFinal"]] <- as.matrix(r2$mat)
}else{
warning("Optimization step-1 failed. Matrix obtained is not positive-semidefinite.
To approximate Matrix of step-1 to its nearest positive definite correlation matrix set force_estimate=TRUE")
output_optim[["optim"]]<-r
output_optim[["corrMatFinal"]] <- corrMatfinal
}
}
return(output_optim)
}
values_corr <- c(1.00,0.86,0.94,0.94,
0.86,1,NA,NA,
0.94,NA,1,1,
0.94,NA,1,1)
varNames <- c("expCrCl","CGeq","MDRDeq","dummy")
c_start <- matrix(values_corr, ncol = 4, nrow = 4)
rownames(c_start) <- varNames
colnames(c_start)<- varNames
colori <- brewer.pal(7, "Set3")
pal <- colorRampPalette(colori)
#plot correlation graph
plot_graph_corr(c_start,"Graph of Initial Correlation Matrix")
#alternative correlation matrix plot
#COL1(sequential = c("Oranges", "Purples", "Reds", "Blues", "Greens",
#                  "Greys", "OrRd", "YlOrRd", "YlOrBr", "YlGn"), n = 200)
corrplot(c_start, method="color",number.digits = 2,
addCoef.col = "black", # Add coefficient of correlation
tl.col="black", tl.srt=45, #Text label color and rotation
# hide correlation coefficient on the principal diagonal
diag=T,col.lim = c(20, 30),
col = pal(7))#COL1('YlGn'))
#get bounds of correlations
estimate_corr_bounds(c_start)
#estimate indirect correlations
corr_est_results <- prova(c_start)
#show final correlation matrix with estimated values
prova <- corr_est_results$corrMatFinal
plot_graph_corr(c_final,"Graph of Final Correlation Matrix")
#plot correlations estimated
corrplot(c_final, method="color",number.digits = 2,
addCoef.col = "black", # Add coefficient of correlation
tl.col="black", tl.srt=45, #Text label color and rotation
# hide correlation coefficient on the principal diagonal
diag=T,col.lim = c(20, 30),
col = pal(7))#COL1('YlGn'))
library(mvLognCorrEst)
library(corrplot)#plot of matrices
library(RColorBrewer)
prova <- function(corrMatStart,force_estimate=FALSE){
#VALIDATE INPUT
#validate_corrMatrix(corrMatStart)
#indirect correlations to estimate must be declared with NA inside the input matrix
if(!any(is.na(corrMatStart))){
stop("No indirect correlations to estimate are declared")
}
#bounds of correlation matrix
bounds <- estimate_corr_bounds(corrMatStart)
#test if all bounds are NA: this implies that all indirect correlations estimates will be set to 0
if(all(is.na(bounds[,3]))&&all(is.na(bounds[,4]))){
list_variables <- paste(paste(bounds[,1],bounds[,2],sep="--"),collapse = " ")
warning(paste("Cannot estimate indirect correlations, paths between all indicated variables are missing:\n",list_variables,sep=""))
plot_graph_corr(corrMatStart,'Independet Variables')
matOpt <- get_corrMatrixOptim(NULL,corrMatStart,bounds)
output_optim <- list()
output_optim[["corrMatFinal"]]<-matOpt
return(output_optim)
}
#set to 0 correlations to be estimated
corrMatStart[is.na(corrMatStart)]<-0
# get indices of couples for which an indirect effect exists according to
#graph path analysis
notNa_idx <- !(is.na(bounds[,3])&is.na(bounds[,4]))
x0 <- bounds[notNa_idx,3]+(sign(bounds[notNa_idx,3])*
((abs(bounds[notNa_idx,4])-abs(bounds[notNa_idx,3]))/2))
#solve constrained optimization problem
r <- pracma::fmincon(x0,optim.fun,lb=bounds[notNa_idx,3],
ub=bounds[notNa_idx,4],cbase=corrMatStart,
var_optim=bounds)
#compute correlation matrix with estimated indirect correlations
corrMatfinal <- get_corrMatrixOptim(r$par,corrMatStart,bounds)
output_optim <- list()
output_optim[["optimizationBounds"]] <-bounds
if(r$val<0){
#optimization successfull
output_optim[["optim"]]<-r
output_optim[["corrMatFinal"]] <- corrMatfinal
return(output_optim)
}else{
if(force_estimate){
warning("Optimization step-1 failed. Matrix obtained is not positive-semidefinite.
Matrix of step-1 will be approximated to its nearest positive definite correlation matrix.
This may change fixed correlations.")
output_optim[["optim1"]] <-r
r2 <- Matrix::nearPD(corrMatfinal,corr = TRUE)
output_optim[["optim2"]] <-r2
output_optim[["corrMatFinal"]] <- as.matrix(r2$mat)
}else{
warning("Optimization step-1 failed. Matrix obtained is not positive-semidefinite.
To approximate Matrix of step-1 to its nearest positive definite correlation matrix set force_estimate=TRUE")
output_optim[["optim"]]<-r
output_optim[["corrMatFinal"]] <- corrMatfinal
}
}
return(output_optim)
}
values_corr <- c(1.00,0.86,0.94,0.94,
0.86,1,NA,NA,
0.94,NA,1,1,
0.94,NA,1,1)
varNames <- c("expCrCl","CGeq","MDRDeq","dummy")
c_start <- matrix(values_corr, ncol = 4, nrow = 4)
rownames(c_start) <- varNames
colnames(c_start)<- varNames
colori <- brewer.pal(7, "Set3")
pal <- colorRampPalette(colori)
#plot correlation graph
plot_graph_corr(c_start,"Graph of Initial Correlation Matrix")
#alternative correlation matrix plot
#COL1(sequential = c("Oranges", "Purples", "Reds", "Blues", "Greens",
#                  "Greys", "OrRd", "YlOrRd", "YlOrBr", "YlGn"), n = 200)
corrplot(c_start, method="color",number.digits = 2,
addCoef.col = "black", # Add coefficient of correlation
tl.col="black", tl.srt=45, #Text label color and rotation
# hide correlation coefficient on the principal diagonal
diag=T,col.lim = c(20, 30),
col = pal(7))#COL1('YlGn'))
#get bounds of correlations
estimate_corr_bounds(c_start)
#estimate indirect correlations
corr_est_results <-estimate_indirect_corr(c_start)
#show final correlation matrix with estimated values
prova <- corr_est_results$corrMatFinal
plot_graph_corr(c_final,"Graph of Final Correlation Matrix")
#plot correlations estimated
corrplot(c_final, method="color",number.digits = 2,
addCoef.col = "black", # Add coefficient of correlation
tl.col="black", tl.srt=45, #Text label color and rotation
# hide correlation coefficient on the principal diagonal
diag=T,col.lim = c(20, 30),
col = pal(7))#COL1('YlGn'))
View(corr_est_results)
corr_est_results[["corrMatFinal"]]
library(mvLognCorrEst)
library(corrplot)#plot of matrices
library(RColorBrewer)
prova <- function(corrMatStart,force_estimate=FALSE){
#VALIDATE INPUT
#validate_corrMatrix(corrMatStart)
#indirect correlations to estimate must be declared with NA inside the input matrix
if(!any(is.na(corrMatStart))){
stop("No indirect correlations to estimate are declared")
}
#bounds of correlation matrix
bounds <- estimate_corr_bounds(corrMatStart)
#test if all bounds are NA: this implies that all indirect correlations estimates will be set to 0
if(all(is.na(bounds[,3]))&&all(is.na(bounds[,4]))){
list_variables <- paste(paste(bounds[,1],bounds[,2],sep="--"),collapse = " ")
warning(paste("Cannot estimate indirect correlations, paths between all indicated variables are missing:\n",list_variables,sep=""))
plot_graph_corr(corrMatStart,'Independet Variables')
matOpt <- get_corrMatrixOptim(NULL,corrMatStart,bounds)
output_optim <- list()
output_optim[["corrMatFinal"]]<-matOpt
return(output_optim)
}
#set to 0 correlations to be estimated
corrMatStart[is.na(corrMatStart)]<-0
# get indices of couples for which an indirect effect exists according to
#graph path analysis
notNa_idx <- !(is.na(bounds[,3])&is.na(bounds[,4]))
x0 <- bounds[notNa_idx,3]+(sign(bounds[notNa_idx,3])*
((abs(bounds[notNa_idx,4])-abs(bounds[notNa_idx,3]))/2))
#solve constrained optimization problem
r <- pracma::fmincon(x0,optim.fun,lb=bounds[notNa_idx,3],
ub=bounds[notNa_idx,4],cbase=corrMatStart,
var_optim=bounds)
#compute correlation matrix with estimated indirect correlations
corrMatfinal <- get_corrMatrixOptim(r$par,corrMatStart,bounds)
output_optim <- list()
output_optim[["optimizationBounds"]] <-bounds
if(r$val<0){
#optimization successfull
output_optim[["optim"]]<-r
output_optim[["corrMatFinal"]] <- corrMatfinal
return(output_optim)
}else{
if(force_estimate){
warning("Optimization step-1 failed. Matrix obtained is not positive-semidefinite.
Matrix of step-1 will be approximated to its nearest positive definite correlation matrix.
This may change fixed correlations.")
output_optim[["optim1"]] <-r
r2 <- Matrix::nearPD(corrMatfinal,corr = TRUE)
output_optim[["optim2"]] <-r2
output_optim[["corrMatFinal"]] <- as.matrix(r2$mat)
}else{
warning("Optimization step-1 failed. Matrix obtained is not positive-semidefinite.
To approximate Matrix of step-1 to its nearest positive definite correlation matrix set force_estimate=TRUE")
output_optim[["optim"]]<-r
output_optim[["corrMatFinal"]] <- corrMatfinal
}
}
return(output_optim)
}
values_corr <- c(1.00,0.86,0.94,0.94,
0.86,1,NA,NA,
0.94,NA,0.99,1,
0.94,NA,0.99,1)
varNames <- c("expCrCl","CGeq","MDRDeq","dummy")
c_start <- matrix(values_corr, ncol = 4, nrow = 4)
rownames(c_start) <- varNames
colnames(c_start)<- varNames
colori <- brewer.pal(7, "Set3")
pal <- colorRampPalette(colori)
#plot correlation graph
plot_graph_corr(c_start,"Graph of Initial Correlation Matrix")
#alternative correlation matrix plot
#COL1(sequential = c("Oranges", "Purples", "Reds", "Blues", "Greens",
#                  "Greys", "OrRd", "YlOrRd", "YlOrBr", "YlGn"), n = 200)
corrplot(c_start, method="color",number.digits = 2,
addCoef.col = "black", # Add coefficient of correlation
tl.col="black", tl.srt=45, #Text label color and rotation
# hide correlation coefficient on the principal diagonal
diag=T,col.lim = c(20, 30),
col = pal(7))#COL1('YlGn'))
#get bounds of correlations
estimate_corr_bounds(c_start)
#estimate indirect correlations
corr_est_results <-estimate_indirect_corr(c_start)
#show final correlation matrix with estimated values
prova <- corr_est_results$corrMatFinal
plot_graph_corr(c_final,"Graph of Final Correlation Matrix")
#plot correlations estimated
corrplot(c_final, method="color",number.digits = 2,
addCoef.col = "black", # Add coefficient of correlation
tl.col="black", tl.srt=45, #Text label color and rotation
# hide correlation coefficient on the principal diagonal
diag=T,col.lim = c(20, 30),
col = pal(7))#COL1('YlGn'))
View(corr_est_results)
eig(corr_est_results$corrMatFinal)
eigen(corr_est_results$corrMatFinal)
eigen(corr_est_results$corrMatFinal)$values[4]
debugSource('C:/Users/AlessandroDeCarlo/Desktop/DT/projs/est.R')
bounds
r <- pracma::fminbnd(x0,optim.fun,a=bounds[notNa_idx,3],
b=bounds[notNa_idx,4])
optim.fun
debugSource('C:/Users/AlessandroDeCarlo/Desktop/DT/projs/est.R')
debugSource('C:/Users/AlessandroDeCarlo/Desktop/DT/projs/est.R')
r <- pracma::fminbnd(x0,optim.fun,a = bounds[notNa_idx,
3], b = bounds[notNa_idx, 4], cbase = corrMatStart,
var_optim = bounds)
optim.fun()
r <- pracma::fminbnd(x0,optim.fun,a = bounds[notNa_idx,
3], b = bounds[notNa_idx, 4], cbase = corrMatStart,
var_optim = bounds)
x0
r <- pracma::fminbnd(optim.fun,a = bounds[notNa_idx,
3], b = bounds[notNa_idx, 4], cbase = corrMatStart,
var_optim = bounds)
r
get_corrMatrixOptim(r$xmin, corrMatStart,
bounds)
eigen(get_corrMatrixOptim(r$xmin, corrMatStart,
bounds))
get_corrMatrixOptim(r$xmin, corrMatStart,
bounds)
r
###### PREAMBLE ########################################################
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list=ls())
library(dplyr)
library(bigrquery)
library(glue)
library(data.table)
projectid <- "deepqlearning-342122"
################## raw data #############################################
adm <- read.csv("adm.csv")
meas <- read.csv("meas.csv")
subjs <- unique(adm$stay_id)
adm_list <- list()
# for(i in 1:length(subjs)){
#     adm_i <- adm %>% filter(stay_id==subjs[i]) %>% arrange(starttime)
#     first_adm <- adm_i %>% slice(1:1)
#
#     if(first_adm$amountuom == "dose"){
#         sbj_id <- first_adm$subject_id
#         hd_id <- first_adm$hadm_id
#         time_th <- first_adm$starttime
#
#         query_body <- "SELECT * FROM `deepqlearning-342122.MIMIC4_v2.prescriptions`
#                where
#                subject_id = {sbj_id} and
#                hadm_id = {hd_id} and starttime <='{time_th}'
#                and lower(drug) like 'vancom%'
#                and route = 'IV'"
#
#         # Set your query
#         sql <- glue(query_body)
#         # Run the query; this returns a bq_table object that you can query further
#         tb <- bq_project_query(projectid, sql)
#         # Store  the data in a tibble
#         sample <-bq_table_download(tb)
#
#         if(nrow(sample)>0){
#             sample <- sample %>% filter(starttime==max(sample$starttime))
#
#             if(nrow(sample) > 1){
#                 sample <- sample %>% slice(1:1)
#             }
#
#             if(sample$dose_unit_rx == "mg"){
#                 first_adm$amount <- as.numeric(sample$dose_val_rx)
#                 first_adm$amountuom <- sample$dose_unit_rx
#             }else if(sample$dose_unit_rx == "grams"){
#                 first_adm$amount <- as.numeric(sample$dose_val_rx)*1000
#                 first_adm$amountuom <- "mg"
#             }else{
#                 print("DDDDDDDDDDDDDDDDDDDD")
#                 first_adm$amount <- 10000
#                 first_adm$amountuom <- "mg"
#             }
#
#
#         }else{
#             first_adm$amount <- 10000
#             first_adm$amountuom <- "mg"
#         }
#     }else if(first_adm$amountuom == "grams"){
#         first_adm$amount <- as.numeric(first_adm$amount)*1000
#         first_adm$amountuom <- "mg"
#     }
#
#     adm_list[[i]] <- first_adm
#
#
#
# }
##################
meas$charttime  <- as.POSIXct(meas$charttime)
keep_list <- list()
#filtro soggetti che hanno la prima misurazione prima della prima dose riportata
for(i in 1:length(subjs)){
adm_i <- adm %>% filter(stay_id==subjs[i]) %>% arrange(starttime)
adm_i$starttime <- as.POSIXct(adm_i$starttime)
first_adm <- adm_i %>% slice(1:1)
meas_i <- meas %>% filter(stay_id==subjs[i]) %>% arrange(charttime) %>% slice(1:1)
if(meas_i$charttime>=adm_i$starttime){
keep_list <- append(keep_list,subjs[i])
}
}
keep_list <- as.array(keep_list)
for (i in 1:length(keep_list)) {
subj_list <- list()
adm_i <- adm %>% filter(stay_id==keep_list[i]) %>% arrange(starttime)
for (j in 1:nrow(adm_i)) {
adm_ij <- adm_i[j,]
uom <- adm_ij$amountuom
if(uom=="grams"){
adm_ij$amount <- as.numeric(adm_ij$amount)*1000
adm_ij$amountuom <- "mg"
}else{
sbj_id <- adm_ij$subject_id
hd_id <- adm_ij$hadm_id
time_th <- adm_ij$starttime
query_body <- "SELECT * FROM `deepqlearning-342122.MIMIC4_v2.prescriptions`
where
subject_id = {sbj_id} and
hadm_id = {hd_id} and starttime <='{time_th}'
and lower(drug) like 'vancom%'
and route = 'IV'"
# Set your query
sql <- glue(query_body)
# Run the query; this returns a bq_table object that you can query further
tb <- bq_project_query(projectid, sql)
# Store  the data in a tibble
sample <-bq_table_download(tb)
if(nrow(sample)>0){
sample <- sample %>% filter(starttime==max(sample$starttime))
if(nrow(sample) > 1){
sample <- sample %>% slice(1:1)
}
if(sample$dose_unit_rx == "mg"){
adm_ij$amount <- as.numeric(sample$dose_val_rx)
adm_ij$amountuom <- sample$dose_unit_rx
}else if(sample$dose_unit_rx == "grams"){
adm_ij$amount <- as.numeric(sample$dose_val_rx)*1000
adm_ij$amountuom <- "mg"
}else{
adm_ij$amount <- 10000
adm_ij$amountuom <- "mg"
}
}else{
adm_ij$amount <- 1000
adm_ij$amountuom <- "mg"
}
}
subj_list[[j]]<-adm_ij
}
adm_list[[i]] <- rbindlist(subj_list)
}
